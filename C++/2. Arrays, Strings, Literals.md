## Arrays
> While dealing with arrays, take care of out of bounds error because in debug mode you will get error but in release mode you will get access to memory location array\[-1] and you might change it to something which might make the program break
> 
```cpp
#include<iostream>

int main()
{
    int a[5]; // declaration to occupy memory for 5 integers
    int * arr = a; // pointer to first int element
    * (arr + 2) = 2; // cpp knows the pointer is for int, so ptr + 2 will move 32*2 bits ahead (or 4 bytes ahead two times)
    std::cout<<arr[2];
    return 0;
}

```

### Stack vs. Heap Arrays

#### Stack Arrays

**Declaration:**

```cpp
int arr[10];  // Fixed-size array on stack
int size = sizeof(arr)/sizeof(arr[0]);
```

**Characteristics:**

- Allocated automatically within a function scope.
- Fixed size (must be known at compile time).
- Fast allocation/deallocation.
- Limited by stack size (~1MB-8MB in most systems).

**Use Cases:**

- When size is small and known at compile time.
- When you need fast access without memory management overhead.

---

#### **Heap Arrays**

**Declaration:**

```cpp
int * arr = new int[10];  // Dynamic allocation
// Above size trick wont work here as the size of the pointer is 4 bytes
// To maintain size, wrap this pointer in a class and maintain size integer there
```

**Characteristics:**

- Allocated using `new` or `malloc`.
- Can be resized (`std::vector` preferred for this).
- Slower allocation/deallocation.
- Must be manually freed (`delete[] arr;`).

**Use Cases:**

- When size is unknown at compile time.
- When large memory allocation is required.
- When data needs to persist beyond function scope.

---

Best Practices:

- Use **stack** whenever possible for efficiency.
- Prefer **`std::vector<int>`** over raw heap arrays for safety.
- Always free heap memory to avoid leaks.

Example
```cpp
#include<iostream>

class Arr{
public:
    int arr[5];
    
    Arr(){
        for(int i=0; i<5; i++){
            arr[i]=1;
        }
    }
};

int main()
{
    Arr a;
    std::cout<<a.arr[0]<<std::endl;
    return 0;
}

```

Going to memory location of Arr we will find the array
In contrast to
```cpp
#include<iostream>

class Arr{
public:
    int * arr = new int[5];
    
    Arr(){
        for(int i=0; i<5; i++){
            arr[i]=1;
        }
    }
};

int main()
{
    Arr a;
    std::cout<<a.arr[0]<<std::endl;
    return 0;
}

```
Going to memory location of Arr we will find the memory location of arr

### Array of dynamic size
```cpp
#include<iostream>

class Arr{
public:
    int * arr;
    
    Arr(int n){
        arr = new int[n];
        for(int i=0; i<n; i++){
            arr[i]=1;
        }
    }
};

int main()
{
    Arr a = Arr(10);
    std::cout<<a.arr[0]<<std::endl;
    return 0;
}

```

## String
Defining a string without string library
```cpp
#include<iostream>

int main()
{
    const char * str = "Bhavneek";  // const not needed, but as string is immutable its convient to use const keyword for debugging
    std::cout<<str<<std::endl;
    return 0;
}
```
> Notice str is a char pointer but we can still print the whole string , unlike arrays where printing the pointer will only printing memory location value. But what cpp does is after allocating chars in array like manner, at the end it puts a '0' at the memory
```cpp

```