
---

## **1. Schema Design & Validation**  
### **Common Schema Types**  
Mongoose supports various schema types, including:  
- **Primitives**: `String`, `Number`, `Boolean`, `Date`, `Buffer`.  
- **Complex Types**: `ObjectId` (for references), `Array`, `Map`, `Mixed` (flexible type).  

### **Field Validation**  
Add validation rules directly to the schema:  
```javascript
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, 'Email is required'], // Custom error message
    unique: true, // Enforce uniqueness
    lowercase: true, // Convert to lowercase
    trim: true, // Remove whitespace
    match: [/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/, 'Invalid email format']
  },
  age: {
    type: Number,
    min: [18, 'Minimum age is 18'],
    max: 100
  },
  status: {
    type: String,
    enum: ['active', 'inactive', 'pending'], // Allow only specific values
    default: 'pending'
  },
  createdAt: {
    type: Date,
    default: Date.now // Set default to current timestamp
  }
});
```

### **Virtuals**  
Define computed properties not stored in MongoDB:  
```javascript
userSchema.virtual('fullName').get(function() {
  return `${this.firstName} ${this.lastName}`;
});
```

### **Indexes**  
Improve query performance with indexes:  
```javascript
userSchema.index({ email: 1 }); // Single-field index
userSchema.index({ firstName: 1, lastName: 1 }); // Compound index
```

---

## **2. Advanced CRUD Operations**  
### **Query Modifiers**  
Chain modifiers to refine results:  
```javascript
const users = await User.find({ role: 'admin' })
  .select('name email -_id') // Include/exclude fields
  .sort({ createdAt: -1 }) // Sort by newest first
  .limit(10) // Limit results
  .skip(20); // Pagination
```

### **Query Operators**  
Use MongoDB operators in queries:  
```javascript
// Find users aged 18-30 with emails ending in "@gmail.com"
await User.find({
  age: { $gte: 18, $lte: 30 },
  email: { $regex: /@gmail\.com$/, $options: 'i' }
});
```

### **Update Operators**  
Atomic updates with operators like `$set`, `$inc`, `$push`:  
```javascript
await User.updateOne(
  { _id: userId },
  { 
    $set: { status: 'active' },
    $inc: { loginCount: 1 },
    $push: { logs: new Date() }
  }
);
```

### **Upsert**  
Create a document if it doesnâ€™t exist:  
```javascript
await User.findOneAndUpdate(
  { email: 'alice@example.com' },
  { $set: { name: 'Alice' } },
  { upsert: true, new: true }
);
```

---

## **3. Aggregation Pipeline**  
### **Common Stages**  
- **`$match`**: Filter documents (like `find`).  
- **`$group`**: Group by a field (e.g., calculate totals).  
- **`$project`**: Reshape documents (similar to `select`).  
- **`$lookup`**: Join data from another collection.  
- **`$unwind`**: Deconstruct an array field.  

### **Example: User Statistics**  
```javascript
const pipeline = [
  { $match: { createdAt: { $gte: startDate } } },
  { $lookup: {
      from: 'orders', // Join with orders collection
      localField: '_id',
      foreignField: 'userId',
      as: 'orders'
    } },
  { $unwind: '$orders' },
  { $group: {
      _id: '$role',
      totalSpent: { $sum: '$orders.amount' },
      averageAge: { $avg: '$age' }
    } }
];
const stats = await User.aggregate(pipeline);
```

---

## **4. Sharding in Depth**  
### **Choosing a Shard Key**  
- **Hashed Sharding**:  
  - Pros: Even data distribution.  
  - Cons: Inefficient range queries.  
  ```bash
  # MongoDB shell command
  sh.shardCollection("db.users", { userId: "hashed" });
  ```
- **Ranged Sharding**:  
  - Pros: Efficient for range queries.  
  - Cons: Potential hotspotting.  
  ```bash
  sh.shardCollection("db.orders", { orderDate: 1 });
  ```

### **Zoned Sharding**  
Assign data to specific shards based on ranges:  
```bash
sh.addShardTag("shard1", "USA");
sh.addTagRange("db.users", { country: "USA" }, { country: "USA" }, "USA");
```

### **Query Optimization**  
- Always include the shard key in queries to target specific shards.  
- Avoid operations that scatter-gather (e.g., `$or` on non-shard keys).  

---

## **5. Transactions & Concurrency**  
### **Retry Logic**  
Handle transient transaction errors with retries:  
```javascript
const runTransaction = async () => {
  const session = await mongoose.startSession();
  let result;
  try {
    await session.withTransaction(async () => {
      // Transaction operations
    });
  } catch (error) {
    if (error.hasErrorLabel('TransientTransactionError')) {
      await runTransaction(); // Retry
    } else {
      throw error;
    }
  } finally {
    session.endSession();
  }
  return result;
};
```

### **Isolation Levels**  
- **Snapshot**: Read from a consistent snapshot (default in MongoDB).  
- **Read Concern & Write Concern**:  
  ```javascript
  await Model.updateOne(filter, update, { 
    session,
    writeConcern: { w: 'majority' } 
  });
  ```

---

## **6. Security & Authentication**  
### **User Roles**  
Common MongoDB roles:  
- `read`: Read-only access.  
- `readWrite`: Read and write access.  
- `dbAdmin`: Database administration.  
- `userAdmin`: Manage users and roles.  

### **Create a User with SCRAM Authentication**  
```javascript
// In MongoDB shell
use admin;
db.createUser({
  user: "admin",
  pwd: "password",
  roles: [ { role: "userAdminAnyDatabase", db: "admin" } ]
});
```

### **TLS/SSL Configuration**  
Enable encrypted connections:  
```javascript
mongoose.connect(uri, {
  ssl: true,
  sslValidate: true,
  sslCA: fs.readFileSync('ca.pem'),
  sslKey: fs.readFileSync('client.key'),
  sslCert: fs.readFileSync('client.pem')
});
```

### **Auditing**  
Track database activity (configured in `mongod.conf`):  
```yaml
auditLog:
  destination: file
  path: /var/log/mongodb/audit.log
  filter: '{ atype: { $in: ["createUser", "dropUser"] } }'
```

---

## **7. Advanced Features**  
### **Middleware (Hooks)**  
Execute code before/after operations:  
```javascript
userSchema.pre('save', function(next) {
  if (this.isModified('password')) {
    this.password = hashPassword(this.password);
  }
  next();
});

userSchema.post('save', function(doc) {
  console.log(`User ${doc._id} saved`);
});
```

### **Plugins**  
Reuse schema logic across models:  
```javascript
function timestampPlugin(schema) {
  schema.add({ createdAt: Date, updatedAt: Date });
  schema.pre('save', function(next) {
    this.updatedAt = new Date();
    if (!this.createdAt) this.createdAt = this.updatedAt;
    next();
  });
}

// Apply plugin to a schema
userSchema.plugin(timestampPlugin);
```

### **Discriminators**  
Inherit schemas for similar document types:  
```javascript
const options = { discriminatorKey: 'type' };
const Product = mongoose.model('Product', new mongoose.Schema({ name: String }, options));

const Book = Product.discriminator('Book', 
  new mongoose.Schema({ author: String }));
const Movie = Product.discriminator('Movie', 
  new mongoose.Schema({ director: String }));
```

---

## **8. Performance & Debugging**  
### **Connection Pooling**  
Configure pool size (default: 5):  
```javascript
mongoose.connect(uri, {
  poolSize: 10, // Max number of sockets
  socketTimeoutMS: 30000 // Close idle connections after 30s
});
```

### **Debugging Queries**  
Log all Mongoose operations:  
```javascript
mongoose.set('debug', (collectionName, method, query, doc) => {
  console.log(`Mongoose: ${collectionName}.${method}`, query);
});
```

---

## **9. Error Handling**  
### **Validation Errors**  
Catch and format errors:  
```javascript
try {
  await user.save();
} catch (error) {
  if (error instanceof mongoose.Error.ValidationError) {
    console.error(Object.values(error.errors).map(e => e.message));
  }
}
```

### **Duplicate Key Errors**  
Handle `E11000` errors:  
```javascript
if (error.code === 11000) {
  console.error('Duplicate key error:', error.keyValue);
}
```

---

## **10. Best Practices**  
- Use **lean queries** for read-only operations to skip hydration:  
  ```javascript
  const users = await User.find().lean(); // Returns plain JS objects
  ```
- Avoid **schema-less** (`Mixed`) types for better validation.  
- Use **projection** to limit returned data.  
- Regularly **rebuild indexes** in production:  
  ```javascript
  await User.collection.reIndex();
  ```

--- 
