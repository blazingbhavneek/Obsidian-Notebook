
- **Docker Workflow (Build, Ship, Run)**:
  - **Build**: Create a Docker image using a Dockerfile, a recipe for packaging applications and dependencies into layers.
  - **Ship**: Distribute the Docker image via a registry (e.g., Docker Hub, GitHub, or private registries) using Docker push/pull commands.
  - **Run**: Execute the image as a container on a server using the Docker run command, managed by the Docker Engine.
- **Docker Image**:
  - Universal app packager, cross-OS, cross-platform, and language-agnostic.
  - Built from a Dockerfile with instructions (e.g., FROM, RUN, COPY) creating layers of files, directories, and metadata.
  - Standardized as OCI image specification.
- **Docker Registry**:
  - Stores and distributes Docker images, standardized as OCI distribution spec.
  - Supports public (e.g., Docker Hub) and private registries, with unique SHA hashes ensuring identical image copies across systems.
- **Docker Container**:
  - Runs the Docker image in an isolated environment (namespace) with its own file system, IP address, and process list.
  - Ensures consistency across different Linux distributions or Windows, supporting redundancy and high availability.
- **Cloud Native Context**: The Cloud Native Computing Foundation (CNCF) assumes the build-ship-run workflow for containerized applications, integral to tools like Kubernetes and Helm.
- **Why Docker Exists**: Addresses friction in software packaging, distribution, and execution, focusing on three key areas: isolation, environments, and speed.
- **Isolation**:
  - Pre-Docker: Servers hosted multiple apps on shared file systems, leading to brittle systems and conflicts (e.g., differing Python/Apache versions).
  - Virtual Machines (VMs): Improved isolation but increased complexity with numerous OS instances, challenging to manage at scale.
  - Docker: Provides VM-like isolation (own IP, file system, process space) without multiple OSs, reducing infrastructure overhead and enabling multiple app versions on one system.
- **Environments**:
  - Problem: "Works on my machine" issue due to varying OS configurations and dependencies across environments (e.g., Mac, Windows, Linux).
  - Docker Solution: Container images (OCI standard) ensure consistent dependencies and behavior across all environments, abstracting the runtime from the host.
- **Speed**:
  - Focus: Speed of business and software lifecycle, not just CPU performance.
  - Evolution: Mainframes → PCs (distributed computing) → VMs (faster resource utilization) → Cloud (instant resources) → Containers (fewer hosts/kernels, isolated workloads).
  - Docker Benefit: Accelerates development, building, testing, and deployment by simplifying and standardizing the process, including serverless platforms running containers.
- **Summary**: Docker enhances isolation within a single OS, minimizes environmental differences, and boosts the speed of software development and deployment, streamlining the software lifecycle.

