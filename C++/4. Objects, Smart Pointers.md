## Object lifetime
1. Object created on stack `Class_name obj;`
	1. Calls the destructor when it goes out of scope (if scope, function scope, or just brackets)
	2. One common mistake is making a Stack variable in a function and then returning its pointer
2. Object created on heap
	1. Have to delete manually by calling `delete obj`

## Smart Pointers

First, we have a class with a const and destr with cout
```cpp
#include <iostream>
#include <memory> // !!!!!!

class Entity{
    public:
        Entity(){
            std::cout<<"Entity Created!"<<std::endl;
        }
        
        ~Entity(){
            std::cout<<"Entity Destroyed!"<<std::endl;
        }
};

```
### Unique Pointers
> Creates object in the stack
> Reason its named unique because the pointer cannot be copied

```cpp
int main() {
    {
        std::unique_ptr<Entity> e = std::make_unique<Entity>();
        e->method_name();
    }
    return 0;
}

```
### Shared pointer, Reference counting and weak pointer
```cpp

int main() {
    std::shared_ptr<Entity> e2;
    {
        std::shared_ptr<Entity> e = std::make_shared<Entity>();
        e2 =e;
    }
    std::cin.get();
    return 0;
}

```
>You will observe here that even if shared ptr has scoped lifetime, if the pointer its shared with is defined out of the scope, it will survive. But the catch is its also storing a ==reference count== somewhere in the memory to count and call the destructor if the count goes to 0.

>If you want a pointer but dont want to increase ref count then you can make a weak pointer, it means  if its defines out of scope and the program goes out of scope then the object will be deleted.